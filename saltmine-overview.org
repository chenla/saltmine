#   -*- mode: org; fill-column: 60 -*-
#+TITLE: Saltmine Overview
#+STARTUP: showall
#+PROPERTY: filename
  :PROPERTIES:
  :CUSTOM_ID: 
  :Name:      /home/deerpig/proj/chenla/saltmine/saltmine-overview.org
  :Created:   2017-05-26T17:36@Prek Leap (11.642600N-104.919210W)
  :ID:        82d92c66-ce35-4cfc-94cd-c48cd6579b53
  :VER:       549067083.896693001
  :GEO:       48P-491193-1287029-15
  :BXID:      proj:XRC7-4777
  :END:
#+INCLUDE: ./inc/head.org
#+INCLUDE: ./inc/macros.org

{{{breadcrumbs}}}

#+HTML: <div class="outline-2" id="meta">
| *Author*  | Brad Collins <brad@chenla.org>             |
| *Date*    | {{{time(%Y-%m-%d %H:%M:%S)}}}              |
#+HTML: </div>

#+TOC: headlines 4

* Introduction


Saltmine is a software stack designed to provide an ITC
infrastructure for a scalable distributed civilization.  Up
until now it has always been seen as a collection of
software applications.  But we're now stepping back and
realizing it needs a broader vision.

So, like our reimagined Bento Box, Saltmine is no longer
simply code, but a set of specifications, data structures
and requirements for delivering a broad set of defined
functionality.  We will likely have a set of uniform APIs,
but other than that it won't matter what actual software
is used to get the job done.  It could be something fast and
close to the the metal in C or Rust, or fantastically rich
code written in Lisp.  It could be written in javascript
or perl or whatever.  It can be off the shelf applications
that are used to provide different parts of the stack -- it
doesn't matter so long as it get's the job done.

---

d9d is the network built out of nodes using saltmine and
bento.  

d9d spins up containers as close to you as possible, that
then allow you to pick up any device and use it as if it
were your own device.

what I'm still unsure about is if we can use IPFS -- but
ipfs is file storage that distributes files across a
network.

saltmine is processing, storage, and messaging 

but it's also about breaking up collections of information
into different overlapping pieces, sometimes scattering
them, sometimes consolidating them.

could we treat containers just like files in IPFS, but each
node that stores something can then fire it up as a
container....

  - knows what you are
  - knows where you are
  - knows who you are
  - knows what role you are in

  - collects surrounding context
    - what you are doing
    - environment, light, temp, humidity, air pressure,
      gravity, noise.
    - identifies who is around you
    - searches for information related to all of these things


  - looks for devices near you to run on
  - looks for displays and interface devices near you

  - keeps track of how many copies of everything there are
  - 

---

#+begin_comment
Still can't seem to get my groove back....
#+end_comment


if we think of everything in saltmine as if it were an ERP
process -- everything in the process of becoming something
else.....  what does that even mean? 

at the same time everything becomes part of the map, which
is a DAG but the graph as map is just how we pull together
context that triggers and informs processes, and a map of a
process is a thread running through the map.

maps represent holonic structures, and a process is just a
segment of a causal chain that propagates through the map,
changing it like light propagating across a light cone.

rule sets determine how we filter and see maps in different
ways, and find things, nodes, patterns etc.  but they also
govern how processes play out -- a rule set defines intent,
or at the least reflects past experience.


where things get interesting is when two graphs come into
contact -- since there are private, shared and public layers
or segments or subnets or whatever, so there is no way of
knowing how one graph is going to fit together with another.

there will be redundancies, gaps and conflicts between them,
all of which are important -- knowing that someone else
knows the same thing, for example, is useful information --
so is knowing that something you know is missing in another
graph. 

a horcrux is constantly integrating new information into its
graph, this is the process of establishing links that weave
new information in the form of relationships.  Most of this
will have to be automated through rule sets which will
constantly need to adapt as they do so.  So indexing is not
enough, each item has to be evaluated to see how it fits
into the graph, and then those new relationships will
propagate throughout the graph so if you change one node,
then the other nodes it is connected to might need to be
changed as well.

it won't only be external things that trigger reevaluation,
it will also be changed how we use our own graphs.  Every
time you view something that information will recome part of
the graph as well.


